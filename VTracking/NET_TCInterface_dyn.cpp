// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "NET_TCInterface.h"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__PrimaryLimits[] = {
  {"lim_el_up", CORBA::TypeCode::PR_double_tc()},
  {"lim_el_dn", CORBA::TypeCode::PR_double_tc()},
  {"lim_az_cw", CORBA::TypeCode::PR_double_tc()},
  {"lim_az_cc", CORBA::TypeCode::PR_double_tc()},
  {"max_az_speed", CORBA::TypeCode::PR_double_tc()},
  {"max_el_speed", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__PrimaryLimits
#  undef _0RL_tc_VTracking_mNET__PrimaryLimits
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__PrimaryLimits = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_PrimaryLimits:1.0", "NET_PrimaryLimits", _0RL_structmember_VTracking_mNET__PrimaryLimits, 6, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_PrimaryLimits = _0RL_tc_VTracking_mNET__PrimaryLimits;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_PrimaryLimits = _0RL_tc_VTracking_mNET__PrimaryLimits;
#endif


static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__RestrictedLowElevationMotionLimits[] = {
  {"low_el", CORBA::TypeCode::PR_double_tc()},
  {"max_az_slew", CORBA::TypeCode::PR_double_tc()},
  {"el_hysteresis", CORBA::TypeCode::PR_double_tc()},
  {"max_az_speed", CORBA::TypeCode::PR_double_tc()},
  {"max_el_speed", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__RestrictedLowElevationMotionLimits
#  undef _0RL_tc_VTracking_mNET__RestrictedLowElevationMotionLimits
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__RestrictedLowElevationMotionLimits = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_RestrictedLowElevationMotionLimits:1.0", "NET_RestrictedLowElevationMotionLimits", _0RL_structmember_VTracking_mNET__RestrictedLowElevationMotionLimits, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_RestrictedLowElevationMotionLimits = _0RL_tc_VTracking_mNET__RestrictedLowElevationMotionLimits;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_RestrictedLowElevationMotionLimits = _0RL_tc_VTracking_mNET__RestrictedLowElevationMotionLimits;
#endif


static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__NotchedInclusionLimitsNotch[] = {
  {"cc_limit", CORBA::TypeCode::PR_double_tc()},
  {"cw_limit", CORBA::TypeCode::PR_double_tc()},
  {"dn_limit", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__NotchedInclusionLimitsNotch
#  undef _0RL_tc_VTracking_mNET__NotchedInclusionLimitsNotch
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__NotchedInclusionLimitsNotch = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_NotchedInclusionLimitsNotch:1.0", "NET_NotchedInclusionLimitsNotch", _0RL_structmember_VTracking_mNET__NotchedInclusionLimitsNotch, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_NotchedInclusionLimitsNotch = _0RL_tc_VTracking_mNET__NotchedInclusionLimitsNotch;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_NotchedInclusionLimitsNotch = _0RL_tc_VTracking_mNET__NotchedInclusionLimitsNotch;
#endif



static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__NotchedInclusionLimits[] = {
  {"notches", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_VTracking_mNET__NotchedInclusionLimitsNotch, &_0RL_tcTrack)},
  {"dn_lim", CORBA::TypeCode::PR_double_tc()},
  {"el_hysteresis", CORBA::TypeCode::PR_double_tc()},
  {"max_az_speed", CORBA::TypeCode::PR_double_tc()},
  {"max_el_speed", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__NotchedInclusionLimits
#  undef _0RL_tc_VTracking_mNET__NotchedInclusionLimits
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__NotchedInclusionLimits = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_NotchedInclusionLimits:1.0", "NET_NotchedInclusionLimits", _0RL_structmember_VTracking_mNET__NotchedInclusionLimits, 5, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_NotchedInclusionLimits = _0RL_tc_VTracking_mNET__NotchedInclusionLimits;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_NotchedInclusionLimits = _0RL_tc_VTracking_mNET__NotchedInclusionLimits;
#endif


static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__KeyLimits[] = {
  {"key_az_cw", CORBA::TypeCode::PR_double_tc()},
  {"key_az_cc", CORBA::TypeCode::PR_double_tc()},
  {"key_el_dn", CORBA::TypeCode::PR_double_tc()},
  {"lim_el_up", CORBA::TypeCode::PR_double_tc()},
  {"lim_el_dn", CORBA::TypeCode::PR_double_tc()},
  {"lim_az_cw", CORBA::TypeCode::PR_double_tc()},
  {"lim_az_cc", CORBA::TypeCode::PR_double_tc()},
  {"max_az_speed", CORBA::TypeCode::PR_double_tc()},
  {"max_el_speed", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__KeyLimits
#  undef _0RL_tc_VTracking_mNET__KeyLimits
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__KeyLimits = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_KeyLimits:1.0", "NET_KeyLimits", _0RL_structmember_VTracking_mNET__KeyLimits, 9, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_KeyLimits = _0RL_tc_VTracking_mNET__KeyLimits;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_KeyLimits = _0RL_tc_VTracking_mNET__KeyLimits;
#endif


static const char* _0RL_enumMember_VTracking_mNET__MotionLimitsType[] = { "NET_ML_NONE", "NET_ML_PRIMARY", "NET_ML_RESTICTED_LOW_EL_MOTION", "NET_ML_NOTCHED_INCLUSION", "NET_ML_KEY", "NET_ML_LIST" };
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__MotionLimitsType = CORBA::TypeCode::PR_enum_tc("IDL:VTracking/NET_MotionLimitsType:1.0", "NET_MotionLimitsType", _0RL_enumMember_VTracking_mNET__MotionLimitsType, 6, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_MotionLimitsType = _0RL_tc_VTracking_mNET__MotionLimitsType;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_MotionLimitsType = _0RL_tc_VTracking_mNET__MotionLimitsType;
#endif

static CORBA::TypeCode_ptr _0RL_ft_VTracking_mNET__MotionLimits = CORBA::TypeCode::PR_forward_tc("IDL:VTracking/NET_MotionLimits:1.0", &_0RL_tcTrack);
#define _0RL_tc_VTracking_mNET__MotionLimits _0RL_ft_VTracking_mNET__MotionLimits

static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__MotionLimitsSeq = CORBA::TypeCode::PR_alias_tc("IDL:VTracking/NET_MotionLimitsSeq:1.0", "NET_MotionLimitsSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_VTracking_mNET__MotionLimits, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_MotionLimitsSeq = _0RL_tc_VTracking_mNET__MotionLimitsSeq;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_MotionLimitsSeq = _0RL_tc_VTracking_mNET__MotionLimitsSeq;
#endif






static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__MotionLimits_mNET__MLList[] = {
  {"seq", _0RL_tc_VTracking_mNET__MotionLimitsSeq},
  {"max_az_speed", CORBA::TypeCode::PR_double_tc()},
  {"max_el_speed", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__MotionLimits_mNET__MLList
#  undef _0RL_tc_VTracking_mNET__MotionLimits_mNET__MLList
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__MotionLimits_mNET__MLList = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_MotionLimits/NET_MLList:1.0", "NET_MLList", _0RL_structmember_VTracking_mNET__MotionLimits_mNET__MLList, 3, &_0RL_tcTrack);

static CORBA::PR_unionMember _0RL_unionMember_VTracking_mNET__MotionLimits[] = {
  {"none", CORBA::TypeCode::PR_boolean_tc(), VTracking::NET_ML_NONE},
  {"primary", _0RL_tc_VTracking_mNET__PrimaryLimits, VTracking::NET_ML_PRIMARY},
  {"low_el", _0RL_tc_VTracking_mNET__RestrictedLowElevationMotionLimits, VTracking::NET_ML_RESTICTED_LOW_EL_MOTION},
  {"notched_inclusion", _0RL_tc_VTracking_mNET__NotchedInclusionLimits, VTracking::NET_ML_NOTCHED_INCLUSION},
  {"key", _0RL_tc_VTracking_mNET__KeyLimits, VTracking::NET_ML_KEY},
  {"list", _0RL_tc_VTracking_mNET__MotionLimits_mNET__MLList, VTracking::NET_ML_LIST}
};
#ifdef _0RL_tc_VTracking_mNET__MotionLimits
#  undef _0RL_tc_VTracking_mNET__MotionLimits
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__MotionLimits = CORBA::TypeCode::PR_union_tc("IDL:VTracking/NET_MotionLimits:1.0", "NET_MotionLimits", _0RL_tc_VTracking_mNET__MotionLimitsType, _0RL_unionMember_VTracking_mNET__MotionLimits, 6, -1, &_0RL_tcTrack);





const CORBA::TypeCode_ptr VTracking::NET_MotionLimits::_tc_NET_MLList = _0RL_tc_VTracking_mNET__MotionLimits_mNET__MLList;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_MotionLimits = _0RL_tc_VTracking_mNET__MotionLimits;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_MotionLimits = _0RL_tc_VTracking_mNET__MotionLimits;
#endif


static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__CorrectionParameters[] = {
  {"enable_offsets", CORBA::TypeCode::PR_boolean_tc()},
  {"enable_corrections", CORBA::TypeCode::PR_boolean_tc()},
  {"enable_vff", CORBA::TypeCode::PR_boolean_tc()},
  {"az_ratio", CORBA::TypeCode::PR_double_tc()},
  {"el_ratio", CORBA::TypeCode::PR_double_tc()},
  {"az_offset", CORBA::TypeCode::PR_double_tc()},
  {"el_offset", CORBA::TypeCode::PR_double_tc()},
  {"az_ns", CORBA::TypeCode::PR_double_tc()},
  {"az_ew", CORBA::TypeCode::PR_double_tc()},
  {"el_udew", CORBA::TypeCode::PR_double_tc()},
  {"fp_az", CORBA::TypeCode::PR_double_tc()},
  {"flex_el_A", CORBA::TypeCode::PR_double_tc()},
  {"flex_el_B", CORBA::TypeCode::PR_double_tc()},
  {"el_pos_vff_s", CORBA::TypeCode::PR_double_tc()},
  {"el_pos_vff_t", CORBA::TypeCode::PR_double_tc()},
  {"el_neg_vff_s", CORBA::TypeCode::PR_double_tc()},
  {"el_neg_vff_t", CORBA::TypeCode::PR_double_tc()},
  {"az_pos_vff_s", CORBA::TypeCode::PR_double_tc()},
  {"az_pos_vff_t", CORBA::TypeCode::PR_double_tc()},
  {"az_neg_vff_s", CORBA::TypeCode::PR_double_tc()},
  {"az_neg_vff_t", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__CorrectionParameters
#  undef _0RL_tc_VTracking_mNET__CorrectionParameters
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__CorrectionParameters = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_CorrectionParameters:1.0", "NET_CorrectionParameters", _0RL_structmember_VTracking_mNET__CorrectionParameters, 21, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_CorrectionParameters = _0RL_tc_VTracking_mNET__CorrectionParameters;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_CorrectionParameters = _0RL_tc_VTracking_mNET__CorrectionParameters;
#endif



static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__TCMiscData[] = {
  {"earth_pos_lon_rad", CORBA::TypeCode::PR_double_tc()},
  {"earth_pos_lat_rad", CORBA::TypeCode::PR_double_tc()},
  {"limits", _0RL_tc_VTracking_mNET__MotionLimits},
  {"corrections", _0RL_tc_VTracking_mNET__CorrectionParameters}
};

#ifdef _0RL_tc_VTracking_mNET__TCMiscData
#  undef _0RL_tc_VTracking_mNET__TCMiscData
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__TCMiscData = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_TCMiscData:1.0", "NET_TCMiscData", _0RL_structmember_VTracking_mNET__TCMiscData, 4, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TCMiscData = _0RL_tc_VTracking_mNET__TCMiscData;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TCMiscData = _0RL_tc_VTracking_mNET__TCMiscData;
#endif


static const char* _0RL_enumMember_VTracking_mNET__CoordinateOffsetType[] = { "NET_CO_NULL", "NET_CO_ONOFF", "NET_CO_WOBBLE", "NET_CO_ORBIT" };
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__CoordinateOffsetType = CORBA::TypeCode::PR_enum_tc("IDL:VTracking/NET_CoordinateOffsetType:1.0", "NET_CoordinateOffsetType", _0RL_enumMember_VTracking_mNET__CoordinateOffsetType, 4, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_CoordinateOffsetType = _0RL_tc_VTracking_mNET__CoordinateOffsetType;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_CoordinateOffsetType = _0RL_tc_VTracking_mNET__CoordinateOffsetType;
#endif

static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__CoordinateOffsetOnOff[] = {
  {"offset_time_rad", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__CoordinateOffsetOnOff
#  undef _0RL_tc_VTracking_mNET__CoordinateOffsetOnOff
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__CoordinateOffsetOnOff = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_CoordinateOffsetOnOff:1.0", "NET_CoordinateOffsetOnOff", _0RL_structmember_VTracking_mNET__CoordinateOffsetOnOff, 1, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_CoordinateOffsetOnOff = _0RL_tc_VTracking_mNET__CoordinateOffsetOnOff;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_CoordinateOffsetOnOff = _0RL_tc_VTracking_mNET__CoordinateOffsetOnOff;
#endif


static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__CoordinateOffsetWobble[] = {
  {"wobble_coords_theta_rad", CORBA::TypeCode::PR_double_tc()},
  {"wobble_coords_phi_rad", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__CoordinateOffsetWobble
#  undef _0RL_tc_VTracking_mNET__CoordinateOffsetWobble
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__CoordinateOffsetWobble = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_CoordinateOffsetWobble:1.0", "NET_CoordinateOffsetWobble", _0RL_structmember_VTracking_mNET__CoordinateOffsetWobble, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_CoordinateOffsetWobble = _0RL_tc_VTracking_mNET__CoordinateOffsetWobble;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_CoordinateOffsetWobble = _0RL_tc_VTracking_mNET__CoordinateOffsetWobble;
#endif


static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__CoordinateOffsetOrbit[] = {
  {"orbit_coords_theta_rad", CORBA::TypeCode::PR_double_tc()},
  {"orbit_coords_phi_rad", CORBA::TypeCode::PR_double_tc()},
  {"orbit_period_day", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__CoordinateOffsetOrbit
#  undef _0RL_tc_VTracking_mNET__CoordinateOffsetOrbit
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__CoordinateOffsetOrbit = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_CoordinateOffsetOrbit:1.0", "NET_CoordinateOffsetOrbit", _0RL_structmember_VTracking_mNET__CoordinateOffsetOrbit, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_CoordinateOffsetOrbit = _0RL_tc_VTracking_mNET__CoordinateOffsetOrbit;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_CoordinateOffsetOrbit = _0RL_tc_VTracking_mNET__CoordinateOffsetOrbit;
#endif





static CORBA::PR_unionMember _0RL_unionMember_VTracking_mNET__CoordinateOffset[] = {
  {"null", CORBA::TypeCode::PR_boolean_tc(), VTracking::NET_CO_NULL},
  {"onoff", _0RL_tc_VTracking_mNET__CoordinateOffsetOnOff, VTracking::NET_CO_ONOFF},
  {"wobble", _0RL_tc_VTracking_mNET__CoordinateOffsetWobble, VTracking::NET_CO_WOBBLE},
  {"orbit", _0RL_tc_VTracking_mNET__CoordinateOffsetOrbit, VTracking::NET_CO_ORBIT}
};
#ifdef _0RL_tc_VTracking_mNET__CoordinateOffset
#  undef _0RL_tc_VTracking_mNET__CoordinateOffset
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__CoordinateOffset = CORBA::TypeCode::PR_union_tc("IDL:VTracking/NET_CoordinateOffset:1.0", "NET_CoordinateOffset", _0RL_tc_VTracking_mNET__CoordinateOffsetType, _0RL_unionMember_VTracking_mNET__CoordinateOffset, 4, -1, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_CoordinateOffset = _0RL_tc_VTracking_mNET__CoordinateOffset;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_CoordinateOffset = _0RL_tc_VTracking_mNET__CoordinateOffset;
#endif


static const char* _0RL_enumMember_VTracking_mNET__TargetObjectType[] = { "NET_TO_RADEC", "NET_TO_AZEL", "NET_TO_STOW", "NET_TO_CV", "NET_TO_UNKNOWN", "NET_TO_NULL" };
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__TargetObjectType = CORBA::TypeCode::PR_enum_tc("IDL:VTracking/NET_TargetObjectType:1.0", "NET_TargetObjectType", _0RL_enumMember_VTracking_mNET__TargetObjectType, 6, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TargetObjectType = _0RL_tc_VTracking_mNET__TargetObjectType;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TargetObjectType = _0RL_tc_VTracking_mNET__TargetObjectType;
#endif

static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__TargetObjectRADec[] = {
  {"ra_rad", CORBA::TypeCode::PR_double_tc()},
  {"dec_rad", CORBA::TypeCode::PR_double_tc()},
  {"epoch", CORBA::TypeCode::PR_double_tc()},
  {"offset", _0RL_tc_VTracking_mNET__CoordinateOffset},
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_VTracking_mNET__TargetObjectRADec
#  undef _0RL_tc_VTracking_mNET__TargetObjectRADec
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__TargetObjectRADec = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_TargetObjectRADec:1.0", "NET_TargetObjectRADec", _0RL_structmember_VTracking_mNET__TargetObjectRADec, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TargetObjectRADec = _0RL_tc_VTracking_mNET__TargetObjectRADec;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TargetObjectRADec = _0RL_tc_VTracking_mNET__TargetObjectRADec;
#endif


static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__TargetObjectStow[] = {
  {"az_rad", CORBA::TypeCode::PR_double_tc()},
  {"el_rad", CORBA::TypeCode::PR_double_tc()},
  {"use_corrections", CORBA::TypeCode::PR_boolean_tc()},
  {"stop_at_target", CORBA::TypeCode::PR_boolean_tc()},
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_VTracking_mNET__TargetObjectStow
#  undef _0RL_tc_VTracking_mNET__TargetObjectStow
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__TargetObjectStow = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_TargetObjectStow:1.0", "NET_TargetObjectStow", _0RL_structmember_VTracking_mNET__TargetObjectStow, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TargetObjectStow = _0RL_tc_VTracking_mNET__TargetObjectStow;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TargetObjectStow = _0RL_tc_VTracking_mNET__TargetObjectStow;
#endif


static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__TargetObjectAzEl[] = {
  {"az_rad", CORBA::TypeCode::PR_double_tc()},
  {"el_rad", CORBA::TypeCode::PR_double_tc()},
  {"use_corrections", CORBA::TypeCode::PR_boolean_tc()},
  {"stop_at_target", CORBA::TypeCode::PR_boolean_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__TargetObjectAzEl
#  undef _0RL_tc_VTracking_mNET__TargetObjectAzEl
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__TargetObjectAzEl = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_TargetObjectAzEl:1.0", "NET_TargetObjectAzEl", _0RL_structmember_VTracking_mNET__TargetObjectAzEl, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TargetObjectAzEl = _0RL_tc_VTracking_mNET__TargetObjectAzEl;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TargetObjectAzEl = _0RL_tc_VTracking_mNET__TargetObjectAzEl;
#endif


static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__TargetObjectCV[] = {
  {"az_rad", CORBA::TypeCode::PR_double_tc()},
  {"el_rad", CORBA::TypeCode::PR_double_tc()},
  {"az_speed", CORBA::TypeCode::PR_double_tc()},
  {"el_speed", CORBA::TypeCode::PR_double_tc()},
  {"mjd_zero", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__TargetObjectCV
#  undef _0RL_tc_VTracking_mNET__TargetObjectCV
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__TargetObjectCV = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_TargetObjectCV:1.0", "NET_TargetObjectCV", _0RL_structmember_VTracking_mNET__TargetObjectCV, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TargetObjectCV = _0RL_tc_VTracking_mNET__TargetObjectCV;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TargetObjectCV = _0RL_tc_VTracking_mNET__TargetObjectCV;
#endif






static CORBA::PR_unionMember _0RL_unionMember_VTracking_mNET__TargetObject[] = {
  {"radec", _0RL_tc_VTracking_mNET__TargetObjectRADec, VTracking::NET_TO_RADEC},
  {"azel", _0RL_tc_VTracking_mNET__TargetObjectAzEl, VTracking::NET_TO_AZEL},
  {"azel", _0RL_tc_VTracking_mNET__TargetObjectAzEl, VTracking::NET_TO_UNKNOWN},
  {"stow", _0RL_tc_VTracking_mNET__TargetObjectStow, VTracking::NET_TO_STOW},
  {"cv", _0RL_tc_VTracking_mNET__TargetObjectCV, VTracking::NET_TO_CV},
  {"null", CORBA::TypeCode::PR_boolean_tc(), VTracking::NET_TO_NULL}
};
#ifdef _0RL_tc_VTracking_mNET__TargetObject
#  undef _0RL_tc_VTracking_mNET__TargetObject
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__TargetObject = CORBA::TypeCode::PR_union_tc("IDL:VTracking/NET_TargetObject:1.0", "NET_TargetObject", _0RL_tc_VTracking_mNET__TargetObjectType, _0RL_unionMember_VTracking_mNET__TargetObject, 6, -1, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TargetObject = _0RL_tc_VTracking_mNET__TargetObject;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TargetObject = _0RL_tc_VTracking_mNET__TargetObject;
#endif


static const char* _0RL_enumMember_VTracking_mNET__DirectionPreference[] = { "NET_DP_NONE", "NET_DP_CW", "NET_DP_CCW" };
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__DirectionPreference = CORBA::TypeCode::PR_enum_tc("IDL:VTracking/NET_DirectionPreference:1.0", "NET_DirectionPreference", _0RL_enumMember_VTracking_mNET__DirectionPreference, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_DirectionPreference = _0RL_tc_VTracking_mNET__DirectionPreference;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_DirectionPreference = _0RL_tc_VTracking_mNET__DirectionPreference;
#endif

static const char* _0RL_enumMember_VTracking_mNET__DriveMode[] = { "NET_DM_STANDBY", "NET_DM_SLEW", "NET_DM_POINT", "NET_DM_SPIN", "NET_DM_SECTOR_SCAN", "NET_DM_RASTER", "NET_DM_CHANGING", "NET_DM_UNKNOWN" };
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__DriveMode = CORBA::TypeCode::PR_enum_tc("IDL:VTracking/NET_DriveMode:1.0", "NET_DriveMode", _0RL_enumMember_VTracking_mNET__DriveMode, 8, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_DriveMode = _0RL_tc_VTracking_mNET__DriveMode;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_DriveMode = _0RL_tc_VTracking_mNET__DriveMode;
#endif

static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__DriveStatus[] = {
  {"driveangle_deg", CORBA::TypeCode::PR_double_tc()},
  {"driveMode", _0RL_tc_VTracking_mNET__DriveMode},
  {"servo1Fail", CORBA::TypeCode::PR_boolean_tc()},
  {"servo2Fail", CORBA::TypeCode::PR_boolean_tc()},
  {"servoOn", CORBA::TypeCode::PR_boolean_tc()},
  {"brakeReleased", CORBA::TypeCode::PR_boolean_tc()},
  {"limitCwUp", CORBA::TypeCode::PR_boolean_tc()},
  {"limitCcwDown", CORBA::TypeCode::PR_boolean_tc()},
  {"positionFault", CORBA::TypeCode::PR_boolean_tc()},
  {"positionComplete", CORBA::TypeCode::PR_boolean_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__DriveStatus
#  undef _0RL_tc_VTracking_mNET__DriveStatus
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__DriveStatus = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_DriveStatus:1.0", "NET_DriveStatus", _0RL_structmember_VTracking_mNET__DriveStatus, 10, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_DriveStatus = _0RL_tc_VTracking_mNET__DriveStatus;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_DriveStatus = _0RL_tc_VTracking_mNET__DriveStatus;
#endif




static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__PositionerStatus[] = {
  {"az", _0RL_tc_VTracking_mNET__DriveStatus},
  {"el", _0RL_tc_VTracking_mNET__DriveStatus},
  {"azTravelledCCW", CORBA::TypeCode::PR_boolean_tc()},
  {"azCableWrap", CORBA::TypeCode::PR_double_tc()},
  {"interlock", CORBA::TypeCode::PR_boolean_tc()},
  {"interlockAzPullCord", CORBA::TypeCode::PR_boolean_tc()},
  {"interlockAzStowPin", CORBA::TypeCode::PR_boolean_tc()},
  {"interlockElStowPin", CORBA::TypeCode::PR_boolean_tc()},
  {"interlockAzDoorOpen", CORBA::TypeCode::PR_boolean_tc()},
  {"interlockElDoorOpen", CORBA::TypeCode::PR_boolean_tc()},
  {"interlockSafeSwitch", CORBA::TypeCode::PR_boolean_tc()},
  {"remoteControl", CORBA::TypeCode::PR_boolean_tc()},
  {"checksumOK", CORBA::TypeCode::PR_boolean_tc()},
  {"msgBadFrame", CORBA::TypeCode::PR_boolean_tc()},
  {"msgCommandInvalid", CORBA::TypeCode::PR_boolean_tc()},
  {"msgInputOverrun", CORBA::TypeCode::PR_boolean_tc()},
  {"msgOutputOverrun", CORBA::TypeCode::PR_boolean_tc()},
  {"relay1", CORBA::TypeCode::PR_boolean_tc()},
  {"relay2", CORBA::TypeCode::PR_boolean_tc()},
  {"Analog1", CORBA::TypeCode::PR_double_tc()},
  {"Analog2", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__PositionerStatus
#  undef _0RL_tc_VTracking_mNET__PositionerStatus
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__PositionerStatus = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_PositionerStatus:1.0", "NET_PositionerStatus", _0RL_structmember_VTracking_mNET__PositionerStatus, 21, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_PositionerStatus = _0RL_tc_VTracking_mNET__PositionerStatus;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_PositionerStatus = _0RL_tc_VTracking_mNET__PositionerStatus;
#endif


static const char* _0RL_enumMember_VTracking_mNET__TrackingState[] = { "NET_TS_STOP", "NET_TS_SLEW", "NET_TS_TRACK", "NET_TS_RESTRICTED_MOTION", "NET_TS_RAMP_DOWN", "NET_TS_COM_FAILURE" };
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__TrackingState = CORBA::TypeCode::PR_enum_tc("IDL:VTracking/NET_TrackingState:1.0", "NET_TrackingState", _0RL_enumMember_VTracking_mNET__TrackingState, 6, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TrackingState = _0RL_tc_VTracking_mNET__TrackingState;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TrackingState = _0RL_tc_VTracking_mNET__TrackingState;
#endif

static const char* _0RL_enumMember_VTracking_mNET__TrackingRequest[] = { "NET_REQ_STOP", "NET_REQ_SLEW", "NET_REQ_TRACK" };
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__TrackingRequest = CORBA::TypeCode::PR_enum_tc("IDL:VTracking/NET_TrackingRequest:1.0", "NET_TrackingRequest", _0RL_enumMember_VTracking_mNET__TrackingRequest, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TrackingRequest = _0RL_tc_VTracking_mNET__TrackingRequest;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TrackingRequest = _0RL_tc_VTracking_mNET__TrackingRequest;
#endif




static CORBA::PR_structMember _0RL_structmember_VTracking_mNET__StateElements[] = {
  {"target", _0RL_tc_VTracking_mNET__TargetObject},
  {"direction_preference", _0RL_tc_VTracking_mNET__DirectionPreference},
  {"status", _0RL_tc_VTracking_mNET__PositionerStatus},
  {"last_az_driveangle_deg", CORBA::TypeCode::PR_double_tc()},
  {"last_el_driveangle_deg", CORBA::TypeCode::PR_double_tc()},
  {"az_driveangle_estimated_speed_dps", CORBA::TypeCode::PR_double_tc()},
  {"el_driveangle_estimated_speed_dps", CORBA::TypeCode::PR_double_tc()},
  {"state", _0RL_tc_VTracking_mNET__TrackingState},
  {"req", _0RL_tc_VTracking_mNET__TrackingRequest},
  {"tv_tv_sec", CORBA::TypeCode::PR_long_tc()},
  {"tv_tv_usec", CORBA::TypeCode::PR_long_tc()},
  {"mjd", CORBA::TypeCode::PR_double_tc()},
  {"last_mjd", CORBA::TypeCode::PR_double_tc()},
  {"timeangle_rad", CORBA::TypeCode::PR_double_tc()},
  {"lmst_rad", CORBA::TypeCode::PR_double_tc()},
  {"last_has_object", CORBA::TypeCode::PR_boolean_tc()},
  {"has_object", CORBA::TypeCode::PR_boolean_tc()},
  {"tel_azel_az_rad", CORBA::TypeCode::PR_double_tc()},
  {"tel_azel_el_rad", CORBA::TypeCode::PR_double_tc()},
  {"obj_azel_az_rad", CORBA::TypeCode::PR_double_tc()},
  {"obj_azel_el_rad", CORBA::TypeCode::PR_double_tc()},
  {"anticipation", CORBA::TypeCode::PR_double_tc()},
  {"last_cmd_az_driveangle_deg", CORBA::TypeCode::PR_double_tc()},
  {"last_cmd_el_driveangle_deg", CORBA::TypeCode::PR_double_tc()},
  {"cmd_az_driveangle_deg", CORBA::TypeCode::PR_double_tc()},
  {"cmd_el_driveangle_deg", CORBA::TypeCode::PR_double_tc()},
  {"az_slew_speed_dps", CORBA::TypeCode::PR_double_tc()},
  {"el_slew_speed_dps", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_VTracking_mNET__StateElements
#  undef _0RL_tc_VTracking_mNET__StateElements
#endif
static CORBA::TypeCode_ptr _0RL_tc_VTracking_mNET__StateElements = CORBA::TypeCode::PR_struct_tc("IDL:VTracking/NET_StateElements:1.0", "NET_StateElements", _0RL_structmember_VTracking_mNET__StateElements, 28, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_StateElements = _0RL_tc_VTracking_mNET__StateElements;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_StateElements = _0RL_tc_VTracking_mNET__StateElements;
#endif



static CORBA::TypeCode_ptr _0RL_tc_VTracking_mTCIReadonly = CORBA::TypeCode::PR_exception_tc("IDL:VTracking/TCIReadonly:1.0", "TCIReadonly", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_TCIReadonly = _0RL_tc_VTracking_mTCIReadonly;
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_TCIReadonly = _0RL_tc_VTracking_mTCIReadonly;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace VTracking { 
  const ::CORBA::TypeCode_ptr _tc_NET_TCInterface = CORBA::TypeCode::PR_interface_tc("IDL:VTracking/NET_TCInterface:1.0", "NET_TCInterface", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr VTracking::_tc_NET_TCInterface = CORBA::TypeCode::PR_interface_tc("IDL:VTracking/NET_TCInterface:1.0", "NET_TCInterface", &_0RL_tcTrack);
#endif

static void _0RL_VTracking_mNET__PrimaryLimits_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_PrimaryLimits* _p = (VTracking::NET_PrimaryLimits*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__PrimaryLimits_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_PrimaryLimits* _p = new VTracking::NET_PrimaryLimits;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__PrimaryLimits_destructor_fn(void* _v)
{
  VTracking::NET_PrimaryLimits* _p = (VTracking::NET_PrimaryLimits*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_PrimaryLimits& _s)
{
  VTracking::NET_PrimaryLimits* _p = new VTracking::NET_PrimaryLimits(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__PrimaryLimits,
               _0RL_VTracking_mNET__PrimaryLimits_marshal_fn,
               _0RL_VTracking_mNET__PrimaryLimits_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_PrimaryLimits* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__PrimaryLimits,
               _0RL_VTracking_mNET__PrimaryLimits_marshal_fn,
               _0RL_VTracking_mNET__PrimaryLimits_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_PrimaryLimits*& _sp)
{
  return _a >>= (const VTracking::NET_PrimaryLimits*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_PrimaryLimits*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__PrimaryLimits,
                    _0RL_VTracking_mNET__PrimaryLimits_unmarshal_fn,
                    _0RL_VTracking_mNET__PrimaryLimits_marshal_fn,
                    _0RL_VTracking_mNET__PrimaryLimits_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_PrimaryLimits*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_RestrictedLowElevationMotionLimits* _p = (VTracking::NET_RestrictedLowElevationMotionLimits*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_RestrictedLowElevationMotionLimits* _p = new VTracking::NET_RestrictedLowElevationMotionLimits;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_destructor_fn(void* _v)
{
  VTracking::NET_RestrictedLowElevationMotionLimits* _p = (VTracking::NET_RestrictedLowElevationMotionLimits*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_RestrictedLowElevationMotionLimits& _s)
{
  VTracking::NET_RestrictedLowElevationMotionLimits* _p = new VTracking::NET_RestrictedLowElevationMotionLimits(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__RestrictedLowElevationMotionLimits,
               _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_marshal_fn,
               _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_RestrictedLowElevationMotionLimits* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__RestrictedLowElevationMotionLimits,
               _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_marshal_fn,
               _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_RestrictedLowElevationMotionLimits*& _sp)
{
  return _a >>= (const VTracking::NET_RestrictedLowElevationMotionLimits*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_RestrictedLowElevationMotionLimits*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__RestrictedLowElevationMotionLimits,
                    _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_unmarshal_fn,
                    _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_marshal_fn,
                    _0RL_VTracking_mNET__RestrictedLowElevationMotionLimits_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_RestrictedLowElevationMotionLimits*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_NotchedInclusionLimitsNotch* _p = (VTracking::NET_NotchedInclusionLimitsNotch*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_NotchedInclusionLimitsNotch* _p = new VTracking::NET_NotchedInclusionLimitsNotch;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_destructor_fn(void* _v)
{
  VTracking::NET_NotchedInclusionLimitsNotch* _p = (VTracking::NET_NotchedInclusionLimitsNotch*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_NotchedInclusionLimitsNotch& _s)
{
  VTracking::NET_NotchedInclusionLimitsNotch* _p = new VTracking::NET_NotchedInclusionLimitsNotch(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__NotchedInclusionLimitsNotch,
               _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_marshal_fn,
               _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_NotchedInclusionLimitsNotch* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__NotchedInclusionLimitsNotch,
               _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_marshal_fn,
               _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_NotchedInclusionLimitsNotch*& _sp)
{
  return _a >>= (const VTracking::NET_NotchedInclusionLimitsNotch*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_NotchedInclusionLimitsNotch*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__NotchedInclusionLimitsNotch,
                    _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_unmarshal_fn,
                    _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_marshal_fn,
                    _0RL_VTracking_mNET__NotchedInclusionLimitsNotch_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_NotchedInclusionLimitsNotch*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__NotchedInclusionLimits_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_NotchedInclusionLimits* _p = (VTracking::NET_NotchedInclusionLimits*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__NotchedInclusionLimits_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_NotchedInclusionLimits* _p = new VTracking::NET_NotchedInclusionLimits;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__NotchedInclusionLimits_destructor_fn(void* _v)
{
  VTracking::NET_NotchedInclusionLimits* _p = (VTracking::NET_NotchedInclusionLimits*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_NotchedInclusionLimits& _s)
{
  VTracking::NET_NotchedInclusionLimits* _p = new VTracking::NET_NotchedInclusionLimits(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__NotchedInclusionLimits,
               _0RL_VTracking_mNET__NotchedInclusionLimits_marshal_fn,
               _0RL_VTracking_mNET__NotchedInclusionLimits_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_NotchedInclusionLimits* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__NotchedInclusionLimits,
               _0RL_VTracking_mNET__NotchedInclusionLimits_marshal_fn,
               _0RL_VTracking_mNET__NotchedInclusionLimits_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_NotchedInclusionLimits*& _sp)
{
  return _a >>= (const VTracking::NET_NotchedInclusionLimits*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_NotchedInclusionLimits*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__NotchedInclusionLimits,
                    _0RL_VTracking_mNET__NotchedInclusionLimits_unmarshal_fn,
                    _0RL_VTracking_mNET__NotchedInclusionLimits_marshal_fn,
                    _0RL_VTracking_mNET__NotchedInclusionLimits_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_NotchedInclusionLimits*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__KeyLimits_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_KeyLimits* _p = (VTracking::NET_KeyLimits*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__KeyLimits_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_KeyLimits* _p = new VTracking::NET_KeyLimits;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__KeyLimits_destructor_fn(void* _v)
{
  VTracking::NET_KeyLimits* _p = (VTracking::NET_KeyLimits*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_KeyLimits& _s)
{
  VTracking::NET_KeyLimits* _p = new VTracking::NET_KeyLimits(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__KeyLimits,
               _0RL_VTracking_mNET__KeyLimits_marshal_fn,
               _0RL_VTracking_mNET__KeyLimits_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_KeyLimits* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__KeyLimits,
               _0RL_VTracking_mNET__KeyLimits_marshal_fn,
               _0RL_VTracking_mNET__KeyLimits_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_KeyLimits*& _sp)
{
  return _a >>= (const VTracking::NET_KeyLimits*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_KeyLimits*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__KeyLimits,
                    _0RL_VTracking_mNET__KeyLimits_unmarshal_fn,
                    _0RL_VTracking_mNET__KeyLimits_marshal_fn,
                    _0RL_VTracking_mNET__KeyLimits_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_KeyLimits*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__MotionLimitsType_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_MotionLimitsType* _p = (VTracking::NET_MotionLimitsType*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__MotionLimitsType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_MotionLimitsType* _p = (VTracking::NET_MotionLimitsType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, VTracking::NET_MotionLimitsType _s)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__MotionLimitsType,
               _0RL_VTracking_mNET__MotionLimitsType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_MotionLimitsType& _s)
{
  return _a.PR_extract(_0RL_tc_VTracking_mNET__MotionLimitsType,
                       _0RL_VTracking_mNET__MotionLimitsType_unmarshal_fn,
                       &_s);
}

static void _0RL_VTracking_mNET__MotionLimitsSeq_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_MotionLimitsSeq* _p = (VTracking::NET_MotionLimitsSeq*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__MotionLimitsSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_MotionLimitsSeq* _p = new VTracking::NET_MotionLimitsSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__MotionLimitsSeq_destructor_fn(void* _v)
{
  VTracking::NET_MotionLimitsSeq* _p = (VTracking::NET_MotionLimitsSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_MotionLimitsSeq& _s)
{
  VTracking::NET_MotionLimitsSeq* _p = new VTracking::NET_MotionLimitsSeq(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__MotionLimitsSeq,
               _0RL_VTracking_mNET__MotionLimitsSeq_marshal_fn,
               _0RL_VTracking_mNET__MotionLimitsSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_MotionLimitsSeq* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__MotionLimitsSeq,
               _0RL_VTracking_mNET__MotionLimitsSeq_marshal_fn,
               _0RL_VTracking_mNET__MotionLimitsSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_MotionLimitsSeq*& _sp)
{
  return _a >>= (const VTracking::NET_MotionLimitsSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_MotionLimitsSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__MotionLimitsSeq,
                    _0RL_VTracking_mNET__MotionLimitsSeq_unmarshal_fn,
                    _0RL_VTracking_mNET__MotionLimitsSeq_marshal_fn,
                    _0RL_VTracking_mNET__MotionLimitsSeq_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_MotionLimitsSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__MotionLimits_mNET__MLList_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_MotionLimits::NET_MLList* _p = (VTracking::NET_MotionLimits::NET_MLList*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__MotionLimits_mNET__MLList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_MotionLimits::NET_MLList* _p = new VTracking::NET_MotionLimits::NET_MLList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__MotionLimits_mNET__MLList_destructor_fn(void* _v)
{
  VTracking::NET_MotionLimits::NET_MLList* _p = (VTracking::NET_MotionLimits::NET_MLList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_MotionLimits::NET_MLList& _s)
{
  VTracking::NET_MotionLimits::NET_MLList* _p = new VTracking::NET_MotionLimits::NET_MLList(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__MotionLimits_mNET__MLList,
               _0RL_VTracking_mNET__MotionLimits_mNET__MLList_marshal_fn,
               _0RL_VTracking_mNET__MotionLimits_mNET__MLList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_MotionLimits::NET_MLList* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__MotionLimits_mNET__MLList,
               _0RL_VTracking_mNET__MotionLimits_mNET__MLList_marshal_fn,
               _0RL_VTracking_mNET__MotionLimits_mNET__MLList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_MotionLimits::NET_MLList*& _sp)
{
  return _a >>= (const VTracking::NET_MotionLimits::NET_MLList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_MotionLimits::NET_MLList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__MotionLimits_mNET__MLList,
                    _0RL_VTracking_mNET__MotionLimits_mNET__MLList_unmarshal_fn,
                    _0RL_VTracking_mNET__MotionLimits_mNET__MLList_marshal_fn,
                    _0RL_VTracking_mNET__MotionLimits_mNET__MLList_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_MotionLimits::NET_MLList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__MotionLimits_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_MotionLimits* _p = (VTracking::NET_MotionLimits*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__MotionLimits_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_MotionLimits* _p = new VTracking::NET_MotionLimits;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__MotionLimits_destructor_fn(void* _v)
{
  VTracking::NET_MotionLimits* _p = (VTracking::NET_MotionLimits*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_MotionLimits& _s)
{
  VTracking::NET_MotionLimits* _p = new VTracking::NET_MotionLimits(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__MotionLimits,
               _0RL_VTracking_mNET__MotionLimits_marshal_fn,
               _0RL_VTracking_mNET__MotionLimits_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_MotionLimits* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__MotionLimits,
               _0RL_VTracking_mNET__MotionLimits_marshal_fn,
               _0RL_VTracking_mNET__MotionLimits_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_MotionLimits*& _sp)
{
  return _a >>= (const VTracking::NET_MotionLimits*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_MotionLimits*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__MotionLimits,
                    _0RL_VTracking_mNET__MotionLimits_unmarshal_fn,
                    _0RL_VTracking_mNET__MotionLimits_marshal_fn,
                    _0RL_VTracking_mNET__MotionLimits_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_MotionLimits*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__CorrectionParameters_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_CorrectionParameters* _p = (VTracking::NET_CorrectionParameters*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__CorrectionParameters_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_CorrectionParameters* _p = new VTracking::NET_CorrectionParameters;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__CorrectionParameters_destructor_fn(void* _v)
{
  VTracking::NET_CorrectionParameters* _p = (VTracking::NET_CorrectionParameters*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_CorrectionParameters& _s)
{
  VTracking::NET_CorrectionParameters* _p = new VTracking::NET_CorrectionParameters(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__CorrectionParameters,
               _0RL_VTracking_mNET__CorrectionParameters_marshal_fn,
               _0RL_VTracking_mNET__CorrectionParameters_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_CorrectionParameters* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__CorrectionParameters,
               _0RL_VTracking_mNET__CorrectionParameters_marshal_fn,
               _0RL_VTracking_mNET__CorrectionParameters_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_CorrectionParameters*& _sp)
{
  return _a >>= (const VTracking::NET_CorrectionParameters*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_CorrectionParameters*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__CorrectionParameters,
                    _0RL_VTracking_mNET__CorrectionParameters_unmarshal_fn,
                    _0RL_VTracking_mNET__CorrectionParameters_marshal_fn,
                    _0RL_VTracking_mNET__CorrectionParameters_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_CorrectionParameters*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__TCMiscData_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_TCMiscData* _p = (VTracking::NET_TCMiscData*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__TCMiscData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_TCMiscData* _p = new VTracking::NET_TCMiscData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__TCMiscData_destructor_fn(void* _v)
{
  VTracking::NET_TCMiscData* _p = (VTracking::NET_TCMiscData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_TCMiscData& _s)
{
  VTracking::NET_TCMiscData* _p = new VTracking::NET_TCMiscData(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__TCMiscData,
               _0RL_VTracking_mNET__TCMiscData_marshal_fn,
               _0RL_VTracking_mNET__TCMiscData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_TCMiscData* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__TCMiscData,
               _0RL_VTracking_mNET__TCMiscData_marshal_fn,
               _0RL_VTracking_mNET__TCMiscData_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TCMiscData*& _sp)
{
  return _a >>= (const VTracking::NET_TCMiscData*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_TCMiscData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__TCMiscData,
                    _0RL_VTracking_mNET__TCMiscData_unmarshal_fn,
                    _0RL_VTracking_mNET__TCMiscData_marshal_fn,
                    _0RL_VTracking_mNET__TCMiscData_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_TCMiscData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__CoordinateOffsetType_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_CoordinateOffsetType* _p = (VTracking::NET_CoordinateOffsetType*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__CoordinateOffsetType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_CoordinateOffsetType* _p = (VTracking::NET_CoordinateOffsetType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, VTracking::NET_CoordinateOffsetType _s)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__CoordinateOffsetType,
               _0RL_VTracking_mNET__CoordinateOffsetType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_CoordinateOffsetType& _s)
{
  return _a.PR_extract(_0RL_tc_VTracking_mNET__CoordinateOffsetType,
                       _0RL_VTracking_mNET__CoordinateOffsetType_unmarshal_fn,
                       &_s);
}

static void _0RL_VTracking_mNET__CoordinateOffsetOnOff_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_CoordinateOffsetOnOff* _p = (VTracking::NET_CoordinateOffsetOnOff*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__CoordinateOffsetOnOff_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_CoordinateOffsetOnOff* _p = new VTracking::NET_CoordinateOffsetOnOff;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__CoordinateOffsetOnOff_destructor_fn(void* _v)
{
  VTracking::NET_CoordinateOffsetOnOff* _p = (VTracking::NET_CoordinateOffsetOnOff*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_CoordinateOffsetOnOff& _s)
{
  VTracking::NET_CoordinateOffsetOnOff* _p = new VTracking::NET_CoordinateOffsetOnOff(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__CoordinateOffsetOnOff,
               _0RL_VTracking_mNET__CoordinateOffsetOnOff_marshal_fn,
               _0RL_VTracking_mNET__CoordinateOffsetOnOff_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_CoordinateOffsetOnOff* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__CoordinateOffsetOnOff,
               _0RL_VTracking_mNET__CoordinateOffsetOnOff_marshal_fn,
               _0RL_VTracking_mNET__CoordinateOffsetOnOff_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_CoordinateOffsetOnOff*& _sp)
{
  return _a >>= (const VTracking::NET_CoordinateOffsetOnOff*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_CoordinateOffsetOnOff*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__CoordinateOffsetOnOff,
                    _0RL_VTracking_mNET__CoordinateOffsetOnOff_unmarshal_fn,
                    _0RL_VTracking_mNET__CoordinateOffsetOnOff_marshal_fn,
                    _0RL_VTracking_mNET__CoordinateOffsetOnOff_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_CoordinateOffsetOnOff*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__CoordinateOffsetWobble_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_CoordinateOffsetWobble* _p = (VTracking::NET_CoordinateOffsetWobble*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__CoordinateOffsetWobble_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_CoordinateOffsetWobble* _p = new VTracking::NET_CoordinateOffsetWobble;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__CoordinateOffsetWobble_destructor_fn(void* _v)
{
  VTracking::NET_CoordinateOffsetWobble* _p = (VTracking::NET_CoordinateOffsetWobble*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_CoordinateOffsetWobble& _s)
{
  VTracking::NET_CoordinateOffsetWobble* _p = new VTracking::NET_CoordinateOffsetWobble(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__CoordinateOffsetWobble,
               _0RL_VTracking_mNET__CoordinateOffsetWobble_marshal_fn,
               _0RL_VTracking_mNET__CoordinateOffsetWobble_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_CoordinateOffsetWobble* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__CoordinateOffsetWobble,
               _0RL_VTracking_mNET__CoordinateOffsetWobble_marshal_fn,
               _0RL_VTracking_mNET__CoordinateOffsetWobble_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_CoordinateOffsetWobble*& _sp)
{
  return _a >>= (const VTracking::NET_CoordinateOffsetWobble*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_CoordinateOffsetWobble*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__CoordinateOffsetWobble,
                    _0RL_VTracking_mNET__CoordinateOffsetWobble_unmarshal_fn,
                    _0RL_VTracking_mNET__CoordinateOffsetWobble_marshal_fn,
                    _0RL_VTracking_mNET__CoordinateOffsetWobble_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_CoordinateOffsetWobble*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__CoordinateOffsetOrbit_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_CoordinateOffsetOrbit* _p = (VTracking::NET_CoordinateOffsetOrbit*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__CoordinateOffsetOrbit_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_CoordinateOffsetOrbit* _p = new VTracking::NET_CoordinateOffsetOrbit;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__CoordinateOffsetOrbit_destructor_fn(void* _v)
{
  VTracking::NET_CoordinateOffsetOrbit* _p = (VTracking::NET_CoordinateOffsetOrbit*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_CoordinateOffsetOrbit& _s)
{
  VTracking::NET_CoordinateOffsetOrbit* _p = new VTracking::NET_CoordinateOffsetOrbit(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__CoordinateOffsetOrbit,
               _0RL_VTracking_mNET__CoordinateOffsetOrbit_marshal_fn,
               _0RL_VTracking_mNET__CoordinateOffsetOrbit_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_CoordinateOffsetOrbit* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__CoordinateOffsetOrbit,
               _0RL_VTracking_mNET__CoordinateOffsetOrbit_marshal_fn,
               _0RL_VTracking_mNET__CoordinateOffsetOrbit_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_CoordinateOffsetOrbit*& _sp)
{
  return _a >>= (const VTracking::NET_CoordinateOffsetOrbit*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_CoordinateOffsetOrbit*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__CoordinateOffsetOrbit,
                    _0RL_VTracking_mNET__CoordinateOffsetOrbit_unmarshal_fn,
                    _0RL_VTracking_mNET__CoordinateOffsetOrbit_marshal_fn,
                    _0RL_VTracking_mNET__CoordinateOffsetOrbit_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_CoordinateOffsetOrbit*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__CoordinateOffset_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_CoordinateOffset* _p = (VTracking::NET_CoordinateOffset*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__CoordinateOffset_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_CoordinateOffset* _p = new VTracking::NET_CoordinateOffset;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__CoordinateOffset_destructor_fn(void* _v)
{
  VTracking::NET_CoordinateOffset* _p = (VTracking::NET_CoordinateOffset*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_CoordinateOffset& _s)
{
  VTracking::NET_CoordinateOffset* _p = new VTracking::NET_CoordinateOffset(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__CoordinateOffset,
               _0RL_VTracking_mNET__CoordinateOffset_marshal_fn,
               _0RL_VTracking_mNET__CoordinateOffset_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_CoordinateOffset* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__CoordinateOffset,
               _0RL_VTracking_mNET__CoordinateOffset_marshal_fn,
               _0RL_VTracking_mNET__CoordinateOffset_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_CoordinateOffset*& _sp)
{
  return _a >>= (const VTracking::NET_CoordinateOffset*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_CoordinateOffset*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__CoordinateOffset,
                    _0RL_VTracking_mNET__CoordinateOffset_unmarshal_fn,
                    _0RL_VTracking_mNET__CoordinateOffset_marshal_fn,
                    _0RL_VTracking_mNET__CoordinateOffset_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_CoordinateOffset*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__TargetObjectType_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_TargetObjectType* _p = (VTracking::NET_TargetObjectType*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__TargetObjectType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_TargetObjectType* _p = (VTracking::NET_TargetObjectType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, VTracking::NET_TargetObjectType _s)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObjectType,
               _0RL_VTracking_mNET__TargetObjectType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TargetObjectType& _s)
{
  return _a.PR_extract(_0RL_tc_VTracking_mNET__TargetObjectType,
                       _0RL_VTracking_mNET__TargetObjectType_unmarshal_fn,
                       &_s);
}

static void _0RL_VTracking_mNET__TargetObjectRADec_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_TargetObjectRADec* _p = (VTracking::NET_TargetObjectRADec*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__TargetObjectRADec_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_TargetObjectRADec* _p = new VTracking::NET_TargetObjectRADec;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__TargetObjectRADec_destructor_fn(void* _v)
{
  VTracking::NET_TargetObjectRADec* _p = (VTracking::NET_TargetObjectRADec*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_TargetObjectRADec& _s)
{
  VTracking::NET_TargetObjectRADec* _p = new VTracking::NET_TargetObjectRADec(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObjectRADec,
               _0RL_VTracking_mNET__TargetObjectRADec_marshal_fn,
               _0RL_VTracking_mNET__TargetObjectRADec_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_TargetObjectRADec* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObjectRADec,
               _0RL_VTracking_mNET__TargetObjectRADec_marshal_fn,
               _0RL_VTracking_mNET__TargetObjectRADec_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TargetObjectRADec*& _sp)
{
  return _a >>= (const VTracking::NET_TargetObjectRADec*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_TargetObjectRADec*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__TargetObjectRADec,
                    _0RL_VTracking_mNET__TargetObjectRADec_unmarshal_fn,
                    _0RL_VTracking_mNET__TargetObjectRADec_marshal_fn,
                    _0RL_VTracking_mNET__TargetObjectRADec_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_TargetObjectRADec*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__TargetObjectStow_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_TargetObjectStow* _p = (VTracking::NET_TargetObjectStow*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__TargetObjectStow_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_TargetObjectStow* _p = new VTracking::NET_TargetObjectStow;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__TargetObjectStow_destructor_fn(void* _v)
{
  VTracking::NET_TargetObjectStow* _p = (VTracking::NET_TargetObjectStow*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_TargetObjectStow& _s)
{
  VTracking::NET_TargetObjectStow* _p = new VTracking::NET_TargetObjectStow(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObjectStow,
               _0RL_VTracking_mNET__TargetObjectStow_marshal_fn,
               _0RL_VTracking_mNET__TargetObjectStow_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_TargetObjectStow* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObjectStow,
               _0RL_VTracking_mNET__TargetObjectStow_marshal_fn,
               _0RL_VTracking_mNET__TargetObjectStow_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TargetObjectStow*& _sp)
{
  return _a >>= (const VTracking::NET_TargetObjectStow*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_TargetObjectStow*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__TargetObjectStow,
                    _0RL_VTracking_mNET__TargetObjectStow_unmarshal_fn,
                    _0RL_VTracking_mNET__TargetObjectStow_marshal_fn,
                    _0RL_VTracking_mNET__TargetObjectStow_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_TargetObjectStow*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__TargetObjectAzEl_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_TargetObjectAzEl* _p = (VTracking::NET_TargetObjectAzEl*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__TargetObjectAzEl_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_TargetObjectAzEl* _p = new VTracking::NET_TargetObjectAzEl;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__TargetObjectAzEl_destructor_fn(void* _v)
{
  VTracking::NET_TargetObjectAzEl* _p = (VTracking::NET_TargetObjectAzEl*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_TargetObjectAzEl& _s)
{
  VTracking::NET_TargetObjectAzEl* _p = new VTracking::NET_TargetObjectAzEl(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObjectAzEl,
               _0RL_VTracking_mNET__TargetObjectAzEl_marshal_fn,
               _0RL_VTracking_mNET__TargetObjectAzEl_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_TargetObjectAzEl* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObjectAzEl,
               _0RL_VTracking_mNET__TargetObjectAzEl_marshal_fn,
               _0RL_VTracking_mNET__TargetObjectAzEl_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TargetObjectAzEl*& _sp)
{
  return _a >>= (const VTracking::NET_TargetObjectAzEl*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_TargetObjectAzEl*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__TargetObjectAzEl,
                    _0RL_VTracking_mNET__TargetObjectAzEl_unmarshal_fn,
                    _0RL_VTracking_mNET__TargetObjectAzEl_marshal_fn,
                    _0RL_VTracking_mNET__TargetObjectAzEl_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_TargetObjectAzEl*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__TargetObjectCV_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_TargetObjectCV* _p = (VTracking::NET_TargetObjectCV*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__TargetObjectCV_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_TargetObjectCV* _p = new VTracking::NET_TargetObjectCV;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__TargetObjectCV_destructor_fn(void* _v)
{
  VTracking::NET_TargetObjectCV* _p = (VTracking::NET_TargetObjectCV*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_TargetObjectCV& _s)
{
  VTracking::NET_TargetObjectCV* _p = new VTracking::NET_TargetObjectCV(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObjectCV,
               _0RL_VTracking_mNET__TargetObjectCV_marshal_fn,
               _0RL_VTracking_mNET__TargetObjectCV_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_TargetObjectCV* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObjectCV,
               _0RL_VTracking_mNET__TargetObjectCV_marshal_fn,
               _0RL_VTracking_mNET__TargetObjectCV_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TargetObjectCV*& _sp)
{
  return _a >>= (const VTracking::NET_TargetObjectCV*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_TargetObjectCV*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__TargetObjectCV,
                    _0RL_VTracking_mNET__TargetObjectCV_unmarshal_fn,
                    _0RL_VTracking_mNET__TargetObjectCV_marshal_fn,
                    _0RL_VTracking_mNET__TargetObjectCV_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_TargetObjectCV*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__TargetObject_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_TargetObject* _p = (VTracking::NET_TargetObject*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__TargetObject_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_TargetObject* _p = new VTracking::NET_TargetObject;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__TargetObject_destructor_fn(void* _v)
{
  VTracking::NET_TargetObject* _p = (VTracking::NET_TargetObject*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_TargetObject& _s)
{
  VTracking::NET_TargetObject* _p = new VTracking::NET_TargetObject(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObject,
               _0RL_VTracking_mNET__TargetObject_marshal_fn,
               _0RL_VTracking_mNET__TargetObject_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_TargetObject* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__TargetObject,
               _0RL_VTracking_mNET__TargetObject_marshal_fn,
               _0RL_VTracking_mNET__TargetObject_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TargetObject*& _sp)
{
  return _a >>= (const VTracking::NET_TargetObject*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_TargetObject*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__TargetObject,
                    _0RL_VTracking_mNET__TargetObject_unmarshal_fn,
                    _0RL_VTracking_mNET__TargetObject_marshal_fn,
                    _0RL_VTracking_mNET__TargetObject_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_TargetObject*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__DirectionPreference_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_DirectionPreference* _p = (VTracking::NET_DirectionPreference*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__DirectionPreference_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_DirectionPreference* _p = (VTracking::NET_DirectionPreference*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, VTracking::NET_DirectionPreference _s)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__DirectionPreference,
               _0RL_VTracking_mNET__DirectionPreference_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_DirectionPreference& _s)
{
  return _a.PR_extract(_0RL_tc_VTracking_mNET__DirectionPreference,
                       _0RL_VTracking_mNET__DirectionPreference_unmarshal_fn,
                       &_s);
}

static void _0RL_VTracking_mNET__DriveMode_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_DriveMode* _p = (VTracking::NET_DriveMode*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__DriveMode_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_DriveMode* _p = (VTracking::NET_DriveMode*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, VTracking::NET_DriveMode _s)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__DriveMode,
               _0RL_VTracking_mNET__DriveMode_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_DriveMode& _s)
{
  return _a.PR_extract(_0RL_tc_VTracking_mNET__DriveMode,
                       _0RL_VTracking_mNET__DriveMode_unmarshal_fn,
                       &_s);
}

static void _0RL_VTracking_mNET__DriveStatus_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_DriveStatus* _p = (VTracking::NET_DriveStatus*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__DriveStatus_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_DriveStatus* _p = new VTracking::NET_DriveStatus;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__DriveStatus_destructor_fn(void* _v)
{
  VTracking::NET_DriveStatus* _p = (VTracking::NET_DriveStatus*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_DriveStatus& _s)
{
  VTracking::NET_DriveStatus* _p = new VTracking::NET_DriveStatus(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__DriveStatus,
               _0RL_VTracking_mNET__DriveStatus_marshal_fn,
               _0RL_VTracking_mNET__DriveStatus_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_DriveStatus* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__DriveStatus,
               _0RL_VTracking_mNET__DriveStatus_marshal_fn,
               _0RL_VTracking_mNET__DriveStatus_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_DriveStatus*& _sp)
{
  return _a >>= (const VTracking::NET_DriveStatus*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_DriveStatus*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__DriveStatus,
                    _0RL_VTracking_mNET__DriveStatus_unmarshal_fn,
                    _0RL_VTracking_mNET__DriveStatus_marshal_fn,
                    _0RL_VTracking_mNET__DriveStatus_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_DriveStatus*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__PositionerStatus_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_PositionerStatus* _p = (VTracking::NET_PositionerStatus*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__PositionerStatus_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_PositionerStatus* _p = new VTracking::NET_PositionerStatus;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__PositionerStatus_destructor_fn(void* _v)
{
  VTracking::NET_PositionerStatus* _p = (VTracking::NET_PositionerStatus*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_PositionerStatus& _s)
{
  VTracking::NET_PositionerStatus* _p = new VTracking::NET_PositionerStatus(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__PositionerStatus,
               _0RL_VTracking_mNET__PositionerStatus_marshal_fn,
               _0RL_VTracking_mNET__PositionerStatus_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_PositionerStatus* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__PositionerStatus,
               _0RL_VTracking_mNET__PositionerStatus_marshal_fn,
               _0RL_VTracking_mNET__PositionerStatus_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_PositionerStatus*& _sp)
{
  return _a >>= (const VTracking::NET_PositionerStatus*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_PositionerStatus*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__PositionerStatus,
                    _0RL_VTracking_mNET__PositionerStatus_unmarshal_fn,
                    _0RL_VTracking_mNET__PositionerStatus_marshal_fn,
                    _0RL_VTracking_mNET__PositionerStatus_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_PositionerStatus*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_VTracking_mNET__TrackingState_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_TrackingState* _p = (VTracking::NET_TrackingState*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__TrackingState_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_TrackingState* _p = (VTracking::NET_TrackingState*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, VTracking::NET_TrackingState _s)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__TrackingState,
               _0RL_VTracking_mNET__TrackingState_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TrackingState& _s)
{
  return _a.PR_extract(_0RL_tc_VTracking_mNET__TrackingState,
                       _0RL_VTracking_mNET__TrackingState_unmarshal_fn,
                       &_s);
}

static void _0RL_VTracking_mNET__TrackingRequest_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_TrackingRequest* _p = (VTracking::NET_TrackingRequest*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__TrackingRequest_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_TrackingRequest* _p = (VTracking::NET_TrackingRequest*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, VTracking::NET_TrackingRequest _s)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__TrackingRequest,
               _0RL_VTracking_mNET__TrackingRequest_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TrackingRequest& _s)
{
  return _a.PR_extract(_0RL_tc_VTracking_mNET__TrackingRequest,
                       _0RL_VTracking_mNET__TrackingRequest_unmarshal_fn,
                       &_s);
}

static void _0RL_VTracking_mNET__StateElements_marshal_fn(cdrStream& _s, void* _v)
{
  VTracking::NET_StateElements* _p = (VTracking::NET_StateElements*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mNET__StateElements_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::NET_StateElements* _p = new VTracking::NET_StateElements;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mNET__StateElements_destructor_fn(void* _v)
{
  VTracking::NET_StateElements* _p = (VTracking::NET_StateElements*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::NET_StateElements& _s)
{
  VTracking::NET_StateElements* _p = new VTracking::NET_StateElements(_s);
  _a.PR_insert(_0RL_tc_VTracking_mNET__StateElements,
               _0RL_VTracking_mNET__StateElements_marshal_fn,
               _0RL_VTracking_mNET__StateElements_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_StateElements* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mNET__StateElements,
               _0RL_VTracking_mNET__StateElements_marshal_fn,
               _0RL_VTracking_mNET__StateElements_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_StateElements*& _sp)
{
  return _a >>= (const VTracking::NET_StateElements*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::NET_StateElements*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mNET__StateElements,
                    _0RL_VTracking_mNET__StateElements_unmarshal_fn,
                    _0RL_VTracking_mNET__StateElements_marshal_fn,
                    _0RL_VTracking_mNET__StateElements_destructor_fn,
                    _v)) {
    _sp = (const VTracking::NET_StateElements*)_v;
    return 1;
  }
  return 0;
}


static void _0RL_VTracking_mTCIReadonly_marshal_fn(cdrStream& _s, void* _v)
{
  const VTracking::TCIReadonly* _p = (const VTracking::TCIReadonly*)_v;
  *_p >>= _s;
}
static void _0RL_VTracking_mTCIReadonly_unmarshal_fn(cdrStream& _s, void*& _v)
{
  VTracking::TCIReadonly* _p = new VTracking::TCIReadonly;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_VTracking_mTCIReadonly_destructor_fn(void* _v)
{
  VTracking::TCIReadonly* _p = (VTracking::TCIReadonly*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const VTracking::TCIReadonly& _s)
{
  VTracking::TCIReadonly* _p = new VTracking::TCIReadonly(_s);
  _a.PR_insert(_0RL_tc_VTracking_mTCIReadonly,
               _0RL_VTracking_mTCIReadonly_marshal_fn,
               _0RL_VTracking_mTCIReadonly_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const VTracking::TCIReadonly* _sp)
{
  _a.PR_insert(_0RL_tc_VTracking_mTCIReadonly,
               _0RL_VTracking_mTCIReadonly_marshal_fn,
               _0RL_VTracking_mTCIReadonly_destructor_fn,
               (VTracking::TCIReadonly*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const VTracking::TCIReadonly*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_VTracking_mTCIReadonly,
                    _0RL_VTracking_mTCIReadonly_unmarshal_fn,
                    _0RL_VTracking_mTCIReadonly_marshal_fn,
                    _0RL_VTracking_mTCIReadonly_destructor_fn,
                    _v)) {
    _sp = (const VTracking::TCIReadonly*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cVTracking_mTCIReadonly(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const VTracking::TCIReadonly & _ex = (const VTracking::TCIReadonly &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cVTracking_mTCIReadonly (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const VTracking::TCIReadonly* _ex = (const VTracking::TCIReadonly*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cVTracking_mTCIReadonly {
public:
  _0RL_insertToAny_Singleton__cVTracking_mTCIReadonly() {
    VTracking::TCIReadonly::insertToAnyFn = _0RL_insertToAny__cVTracking_mTCIReadonly;
    VTracking::TCIReadonly::insertToAnyFnNCP = _0RL_insertToAnyNCP__cVTracking_mTCIReadonly;
  }
};
static _0RL_insertToAny_Singleton__cVTracking_mTCIReadonly _0RL_insertToAny_Singleton__cVTracking_mTCIReadonly_;

static void _0RL_VTracking_mNET__TCInterface_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_VTracking_mNET__TCInterface_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(VTracking::NET_TCInterface::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_VTracking_mNET__TCInterface_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, VTracking::NET_TCInterface_ptr _o)
{
  VTracking::NET_TCInterface_ptr _no = VTracking::NET_TCInterface::_duplicate(_o);
  _a.PR_insert(VTracking::_tc_NET_TCInterface,
               _0RL_VTracking_mNET__TCInterface_marshal_fn,
               _0RL_VTracking_mNET__TCInterface_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, VTracking::NET_TCInterface_ptr* _op)
{
  _a.PR_insert(VTracking::_tc_NET_TCInterface,
               _0RL_VTracking_mNET__TCInterface_marshal_fn,
               _0RL_VTracking_mNET__TCInterface_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = VTracking::NET_TCInterface::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, VTracking::NET_TCInterface_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(VTracking::_tc_NET_TCInterface,
                    _0RL_VTracking_mNET__TCInterface_unmarshal_fn,
                    _0RL_VTracking_mNET__TCInterface_marshal_fn,
                    _0RL_VTracking_mNET__TCInterface_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (VTracking::NET_TCInterface_ptr)_r->_ptrToObjRef(VTracking::NET_TCInterface::_PD_repoId);
    else
      _o = VTracking::NET_TCInterface::_nil();
    return 1;
  }
  return 0;
}

