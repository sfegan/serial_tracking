// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "NET_SerialTracking_data.h"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);


static CORBA::TypeCode_ptr _0RL_tc_CommandsNotPermitted = CORBA::TypeCode::PR_exception_tc("IDL:CommandsNotPermitted:1.0", "CommandsNotPermitted", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr _tc_CommandsNotPermitted = _0RL_tc_CommandsNotPermitted;



static CORBA::TypeCode_ptr _0RL_tc_NotStopped = CORBA::TypeCode::PR_exception_tc("IDL:NotStopped:1.0", "NotStopped", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr _tc_NotStopped = _0RL_tc_NotStopped;



static CORBA::TypeCode_ptr _0RL_tc_WrongTargetType = CORBA::TypeCode::PR_exception_tc("IDL:WrongTargetType:1.0", "WrongTargetType", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr _tc_WrongTargetType = _0RL_tc_WrongTargetType;


static const char* _0RL_enumMember_TargetObjectType[] = { "TO_RADEC", "TO_AZEL", "TO_UNKNOWN", "TO_NULL" };
static CORBA::TypeCode_ptr _0RL_tc_TargetObjectType = CORBA::TypeCode::PR_enum_tc("IDL:TargetObjectType:1.0", "TargetObjectType", _0RL_enumMember_TargetObjectType, 4, &_0RL_tcTrack);
const CORBA::TypeCode_ptr _tc_TargetObjectType = _0RL_tc_TargetObjectType;


static void _0RL_CommandsNotPermitted_marshal_fn(cdrStream& _s, void* _v)
{
  const CommandsNotPermitted* _p = (const CommandsNotPermitted*)_v;
  *_p >>= _s;
}
static void _0RL_CommandsNotPermitted_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CommandsNotPermitted* _p = new CommandsNotPermitted;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CommandsNotPermitted_destructor_fn(void* _v)
{
  CommandsNotPermitted* _p = (CommandsNotPermitted*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CommandsNotPermitted& _s)
{
  CommandsNotPermitted* _p = new CommandsNotPermitted(_s);
  _a.PR_insert(_0RL_tc_CommandsNotPermitted,
               _0RL_CommandsNotPermitted_marshal_fn,
               _0RL_CommandsNotPermitted_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CommandsNotPermitted* _sp)
{
  _a.PR_insert(_0RL_tc_CommandsNotPermitted,
               _0RL_CommandsNotPermitted_marshal_fn,
               _0RL_CommandsNotPermitted_destructor_fn,
               (CommandsNotPermitted*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CommandsNotPermitted*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CommandsNotPermitted,
                    _0RL_CommandsNotPermitted_unmarshal_fn,
                    _0RL_CommandsNotPermitted_marshal_fn,
                    _0RL_CommandsNotPermitted_destructor_fn,
                    _v)) {
    _sp = (const CommandsNotPermitted*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCommandsNotPermitted(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CommandsNotPermitted & _ex = (const CommandsNotPermitted &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCommandsNotPermitted (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CommandsNotPermitted* _ex = (const CommandsNotPermitted*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCommandsNotPermitted {
public:
  _0RL_insertToAny_Singleton__cCommandsNotPermitted() {
    CommandsNotPermitted::insertToAnyFn = _0RL_insertToAny__cCommandsNotPermitted;
    CommandsNotPermitted::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCommandsNotPermitted;
  }
};
static _0RL_insertToAny_Singleton__cCommandsNotPermitted _0RL_insertToAny_Singleton__cCommandsNotPermitted_;


static void _0RL_NotStopped_marshal_fn(cdrStream& _s, void* _v)
{
  const NotStopped* _p = (const NotStopped*)_v;
  *_p >>= _s;
}
static void _0RL_NotStopped_unmarshal_fn(cdrStream& _s, void*& _v)
{
  NotStopped* _p = new NotStopped;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_NotStopped_destructor_fn(void* _v)
{
  NotStopped* _p = (NotStopped*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const NotStopped& _s)
{
  NotStopped* _p = new NotStopped(_s);
  _a.PR_insert(_0RL_tc_NotStopped,
               _0RL_NotStopped_marshal_fn,
               _0RL_NotStopped_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const NotStopped* _sp)
{
  _a.PR_insert(_0RL_tc_NotStopped,
               _0RL_NotStopped_marshal_fn,
               _0RL_NotStopped_destructor_fn,
               (NotStopped*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const NotStopped*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_NotStopped,
                    _0RL_NotStopped_unmarshal_fn,
                    _0RL_NotStopped_marshal_fn,
                    _0RL_NotStopped_destructor_fn,
                    _v)) {
    _sp = (const NotStopped*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cNotStopped(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const NotStopped & _ex = (const NotStopped &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cNotStopped (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const NotStopped* _ex = (const NotStopped*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cNotStopped {
public:
  _0RL_insertToAny_Singleton__cNotStopped() {
    NotStopped::insertToAnyFn = _0RL_insertToAny__cNotStopped;
    NotStopped::insertToAnyFnNCP = _0RL_insertToAnyNCP__cNotStopped;
  }
};
static _0RL_insertToAny_Singleton__cNotStopped _0RL_insertToAny_Singleton__cNotStopped_;


static void _0RL_WrongTargetType_marshal_fn(cdrStream& _s, void* _v)
{
  const WrongTargetType* _p = (const WrongTargetType*)_v;
  *_p >>= _s;
}
static void _0RL_WrongTargetType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  WrongTargetType* _p = new WrongTargetType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_WrongTargetType_destructor_fn(void* _v)
{
  WrongTargetType* _p = (WrongTargetType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const WrongTargetType& _s)
{
  WrongTargetType* _p = new WrongTargetType(_s);
  _a.PR_insert(_0RL_tc_WrongTargetType,
               _0RL_WrongTargetType_marshal_fn,
               _0RL_WrongTargetType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const WrongTargetType* _sp)
{
  _a.PR_insert(_0RL_tc_WrongTargetType,
               _0RL_WrongTargetType_marshal_fn,
               _0RL_WrongTargetType_destructor_fn,
               (WrongTargetType*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const WrongTargetType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_WrongTargetType,
                    _0RL_WrongTargetType_unmarshal_fn,
                    _0RL_WrongTargetType_marshal_fn,
                    _0RL_WrongTargetType_destructor_fn,
                    _v)) {
    _sp = (const WrongTargetType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cWrongTargetType(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const WrongTargetType & _ex = (const WrongTargetType &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cWrongTargetType (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const WrongTargetType* _ex = (const WrongTargetType*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cWrongTargetType {
public:
  _0RL_insertToAny_Singleton__cWrongTargetType() {
    WrongTargetType::insertToAnyFn = _0RL_insertToAny__cWrongTargetType;
    WrongTargetType::insertToAnyFnNCP = _0RL_insertToAnyNCP__cWrongTargetType;
  }
};
static _0RL_insertToAny_Singleton__cWrongTargetType _0RL_insertToAny_Singleton__cWrongTargetType_;

static void _0RL_TargetObjectType_marshal_fn(cdrStream& _s, void* _v)
{
  TargetObjectType* _p = (TargetObjectType*)_v;
  *_p >>= _s;
}
static void _0RL_TargetObjectType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  TargetObjectType* _p = (TargetObjectType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, TargetObjectType _s)
{
  _a.PR_insert(_0RL_tc_TargetObjectType,
               _0RL_TargetObjectType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, TargetObjectType& _s)
{
  return _a.PR_extract(_0RL_tc_TargetObjectType,
                       _0RL_TargetObjectType_unmarshal_fn,
                       &_s);
}

